---
title: "Using the LifeInsuranceContracts Package"
author:
- name: Reinhold Kainhofer
  affiliation: Open Tools
  email: reinhold@kainhofer.com

date: "`r Sys.Date()`"
output:
    rmarkdown::html_vignette:
        toc: true
        toc_depth: 3
        fig_width: 7
        fig_height: 5
        number_sections: true
vignette: >
  %\VignetteIndexEntry{Using the LifeInsuranceContracts Package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r setup, echo = FALSE, message=FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
library(knitr)
library(kableExtra)
library(LifeInsuranceContracts)
library(dplyr)
library(tibble)
options(scipen=5)

library(pander)

panderOptions('round', 2)
panderOptions('digits', 12)
panderOptions('keep.trailing.zeros', TRUE)
panderOptions('table.split.table', 120)

kableTable = function(grd, ...) {
  grd %>% 
    kable(...) %>% 
    add_header_above(header = c(1, dim(grd)[[2]]) %>% `names<-`(names(dimnames(grd))), align = "c") %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = F) %>%
    column_spec(1, bold = T, border_right = T)
}



## Modified pandoc.list function that also works with NULL entries in the lists:
pandoc.listRK.return <- function(elements, style = c('bullet', 'ordered', 'roman'), loose = FALSE, add.line.breaks = TRUE, add.end.of.list = TRUE, indent.level = 0, missing = panderOptions('missing')) { #nolint

    ## checks
    if (!is.logical(loose)) {
        stop('Wrong argument provided: loose')
    }

    ## default values
    if (missing(style)) {
        style <- panderOptions('list.style')
    } else {
        style <- match.arg(style)
    }

    ## replace missing values
    w <- which(is.na(elements))
    if (length(w) > 0) {
        elements[w] <- missing
    }

    ## helpers
    elements.l <- length(elements)
    marker     <- switch(style,
                         'bullet'  = rep('* ', elements.l),
                         'ordered' = paste0(1:elements.l, '. '),
                         'roman'   = paste0(as.roman(1:elements.l), '. '))

    ## number of elements should be more than one
    if (elements.l == 0) {
        return('')
    }

    ## recursive call
    i.lag <- 0
    res <- ifelse(add.line.breaks, '\n', '')
    nms = names(elements)
    for (i in 1:elements.l) {
        res <- paste0(res, paste(rep(' ', indent.level * 4), collapse = ''), marker[i - i.lag])
        if (nms[[i]] != "") {
            res <- paste0(res, nms[[i]], ': ')
        }

        if (length(elements[[i]]) <=1 && !is.list(elements[[i]])) {
            res <- paste0(res, elements[[i]], '\n')
        } else {
            i.lag <<- i.lag + 1
            res <- paste0(res, '\n', pandoc.listRK.return(elements[[i]], style, loose, FALSE, FALSE, indent.level + 1))
        }
        res <- paste0(res, ifelse(loose, '\n', ''))
    }

    # res <- paste(sapply(1:elements.l, function(i) {
    #     if (length(elements[[i]]) <= 1 && !is.list(elements[[i]])) {
    #         paste0(paste(rep(' ', indent.level * 4), collapse = ''), marker[i - i.lag], elements[[i]])
    #     } else {
    #         i.lag <<- i.lag + 1
    #         pandoc.listRK.return(elements[[i]], style, loose, FALSE, FALSE, indent.level + 1)
    #     }}),
    #     collapse = '\n', ifelse(loose, '\n', ''))

    ## closing tag
    if (add.end.of.list) {
        res <- paste0(res, ifelse(loose, '', '\n\n'), '<!-- end of list -->\n')
    }
    if (add.line.breaks) {
        res <- add.blank.lines(res)
    }

    return(res)

}

#' @export
pandoc.listRK <- function(...)
    cat(pandoc.listRK.return(...))


```


The LifeInsuranceContracts package provides a full-featured framework to model classical life insurance contracts (non-unit linked). Mathematically, a general life insurance contracts can be defined using death and survival (and disability) benefit vectors to define the cash flows and calculate all premiums and reserves recursively. This powerful approach is taken by the LifeInsuranceContracts package to provide the most flexible contract modelling framework in R.

# General Overview of the Concepts

An insurance contract is described by three different objects;

* `InsuranceContract`: The object describing the actual contract with all 
  contract-specific parameters (age, maturity, sum insured, etc.).
* `InsuranceTarif`: The general (contract-independent) description of the
  insurance product (benefits, present values / reserves, premium calculation,
  premium waivers, surrender value, reserve calculation, premium decomposition).
  It does not store any values (only tarif-provided default values for the 
  insurance contract), but provides all calculation functions. The implementation
  is based on a general approach using cash flows (depending on the type of 
  insurance). Once the cash flows (survival, death and guaranteed) are defined
  for all time steps, all further calculations are idential for all different 
  kinds of life insurance.
* ` ProfitParticipation`: For contracts with profit sharing mechanisms, this
  object describes the profit participation (like the `InsuranceTarif` object
  describes the guaranteed payments) and us used by the `InsuranceContract` 
  object.

While this might at first seem a bit complicated, it allows for very generic
implementations of life insurance products and contracts.


# A simple example: Term life insurance

To understand how the package implements life insurance contracts, let us look
at a simple example:

## Tarif description

Term Life Insurance 

* Public product name '**DeathPlus - Short Term Life Insurance**', Internal ID '**L71-U**'
* Only **death benefits**, no survival benefits
* **Mortality table**: Austrian 2010/12 census table unisex (mixed 65:35 from the male:female tables)
* **Guaranteed interest rate**: 0.5%
* Default contract duration: 5 years (to keep the example short)
* **Regular premium** payments (constant premiums) during the whole contract
<!-- * premiums paid more often than once a year in advance get the following surcharge: -->
<!--     * yearly premiums: 0% surcharge -->
<!--     * half-yearly premiums: 1% surcharge -->
<!--     * quarterly premiums: 1.5% surcharge -->
<!--     * monthly premiums: 2% surcharge -->

**Costs**:

* Aquisition costs: 5\% of the total premium sum
* Administration cost: 1% of the sum insured per year (both during premium payments as well as for paid-up contracts)
* Unit costs: 10 Euro per year (fixed) during premium payments
* Tax: 4% insurance tax (default)

Surrender Value:

* Reserve minus 10% surrender penalty, also applied on premium waiver


## Tariff implementation as an InsuranceTarif object

```{r SimpleExampleRiskTarif}
library(magrittr)
library(MortalityTables)
library(LifeInsuranceContracts)
mortalityTables.load("Austria_Census")

Tarif.L71U = InsuranceTarif$new(
    name = "L71-U",
    type = "wholelife",
    tarif = "DeathPlus - Short Term Life Insurance",
    desc = "Term Life insurance (5 years) with constant sum insured and regular premiums",
    policyPeriod = 5, premiumPeriod = 5,  # premiumPeriod not needed, defaults to maturity

    mortalityTable = mortalityTable.mixed(
      table1 = mort.AT.census.2011.male, weight1 = 0.65, 
      table2 = mort.AT.census.2011.female, weight2 = 0.35
    ),
    i = 0.005, 
    tax = 0.04, 
    costs = initializeCosts(alpha = 0.05, gamma = 0.01, gamma.paidUp = 0.01, unitcosts = 10),
    surrenderValueCalculation = function(surrenderReserve, params, values) { 
      surrenderReserve * 0.9 
    }
);
```

## Calculating one particular contract with the given tariff

With the above product / tariff definition, it is now easy to instantiate 
one particular contract for this tariff. All we need to do is pass the tariff
and the corresponding contract-specific information (mainly age, sum insured
and contract closing) to the `InsuranceContract` object:

```{r SimpleExampleRiskContract}
contract.L71U  = InsuranceContract$new(
  Tarif.L71U, 
  age = 35, 
  contractClosing = as.Date("2020-08-18"), 
  sumInsured = 100000);
```

Just creating the contract will already calculate all cash flows, present values,
premiums, reserves, etc. for the whole contract period. They can be accessed 
through the `contract.L71U$Values` list.

A full list of all possible arguments can be found in the section [All possible parameters and their default values].


Once the contract is created, all values can be accessed like this:

```{r SimpleExampleRiskValuesPremCode, eval=F}
contract.L71U$Values$premiums
```
```{r SimpleExampleRiskValuesPremOut, echo=F}
contract.L71U$Values$premiums %>% kable
```
```{r SimpleExampleRiskValuesResCode, eval=F}
contract.L71U$Values$reserves
```
```{r SimpleExampleRiskValuesResOut, echo=F}
contract.L71U$Values$reserves %>% pander()
```

Looking back at the definition of the tariff, the only spot where the type of
insurance actually came in was the `type` argument of the `InsuranceTarif`
definition. This is one of the most important flags and is central to correct
implementation of a tarif. On the other hand, all it does is to cause different
vectors of survival, death and guaranteed cash flows. Once the cash flows are 
determined, the insurance contract and tariff does not need the insurance type
any more.

In our term life example, the insurance contract's unit cash flows are 1 for death 
benefits (both when premiums are paid and when the contract is paid-up) and for
premiums in advance. All other cash flows (guaranteed, survival or disease cash 
flows) are zero. Similarly, the cost structure described above and implemented
by the `LifeInsuranceContracts::initializeCosts()` function defines all cost cash
flows, which are the starting point for all further calculations (only relevant 
columns of the data.frame are shown):

```{r SimpleExampleRiskCFCode, eval=F}
contract.L71U$Values$cashFlows
```
```{r SimpleExampleRiskCFOut, echo=F}
contract.L71U$Values$cashFlows %>% select(starts_with('premiums'), starts_with('death'), -death_Refund_past ) %>% pander()
```
```{r SimpleExampleRiskCFCostCode, eval=F}
contract.L71U$Values$cashFlowsCosts
```
```{r SimpleExampleRiskCFCostOut, echo=F, results="asis"}
for (base in dimnames(contract.L71U$Values$cashFlowsCosts)[[3]]) {
  cat("* ,,\"", base, "\"\n", sep = "")
  cat(contract.L71U$Values$cashFlowsCosts[,,base ] %>% pander(round = 4, style = "rmarkdown"))
}
```

Once these unit cash flows are set, all insurance contracts are handled identically.
First, present values of each of the cash flows are calculated, from which 
the premiums can be calculated by the equivalence principle.

```{r SimpleExampleRiskPVCode, eval=F}
contract.L71U$Values$presentValues
```
```{r SimpleExampleRiskPVOut, echo=F}
contract.L71U$Values$presentValues %>% as.data.frame() %>% select(starts_with('premiums'), starts_with('death'), -death_Refund_past ) %>% pander(round=5)
```
```{r SimpleExampleRiskPVCostCode, eval=F}
contract.L71U$Values$presentValuesCosts
```
```{r SimpleExampleRiskPVCostOut, echo=F, results="asis"}
for (base in dimnames(contract.L71U$Values$presentValuesCosts)[[3]]) {
  cat("* ,,\"", base, "\"\n", sep = "")
  cat(contract.L71U$Values$presentValuesCosts[,,base ] %>% pander(round = 4, style = "rmarkdown"))
}
```
```{r SimpleExampleRiskPVPremCode, eval=F}
contract.L71U$Values$premiums
```
```{r SimpleExampleRiskPVPremOut, echo=F}
contract.L71U$Values$premiums %>% data.frame() %>% pander()
```

The actual calculation of the premiums has to be in the order gross premium, 
Zillmer premiuem, then net premium. The reason for this particular order is that
some tariffs have a gross premium refund in case of death. So to calculate the
net premium, the gross premium is required. 

The premiums allow the unit cash flows and present values to be converted to 
monetary terms (fields `contract.L71U$Values$absCashFlows` and 
`contract.L71U$Values$absPresentValues`). Also, the reserves of the 
contract can be calculated.

```{r SimpleExampleRiskPremiumsCode, eval=F}
contract.L71U$Values$reserves
```
```{r SimpleExampleRiskPremiumsOut, echo=F}
contract.L71U$Values$reserves %>% pander(digits=2)
```

Also, the premium composition into costs, risk premium, savings premium and 
other components is possible.

```{r SimpleExampleRiskPremiumCompositionCode, eval=F}
contract.L71U$Values$premiumComposition
```
```{r SimpleExampleRiskPremiumCompositionOut, echo=F}
contract.L71U$Values$premiumComposition %>% as.data.frame() %>% select(-loading.frequency, -rebate.premium, -rebate.partner, -profit.advance, -rebate.sum, -charge.noMedicalExam, -premium.risk.actual, -premium.risk.security, -risk.disease, -premium.risk.disease.actual, -premium.risk.disease.security, -starts_with('Zillmer')) %>% pander()
```




As we see, the whole history and future of the contract is calculated as soon 
as it is created. It is, however, also possible to modify a contract later on,
e.g. by stopping premium payments and converting it to a paid-up contract.

```{r SimpleExampleRiskConversionCode, eval=F}
contract.L71U = contract.L71U$premiumWaiver(t = 3)
contract.L71U$Values$reserves
```
```{r SimpleExampleRiskConversionOut, echo=F}
contract.L71U = contract.L71U$premiumWaiver(t = 3)
contract.L71U$Values$reserves %>% pander()
```


## Creating tables with various parameters

When prototyping a new product or creating marketing material, it is often needed
to create tables of premiums, reserves, benefits or surrender values for different
parameters (e.g. different ages, maturities and sums insured for the marketing 
department, or different guaranteed interest rates, mortality tables or costs 
for the product development group). 

This can be easily done by the functions `contractGridPremium()` or `contractGrid()`.
They take one argument `axes`, which gives the parameters for the axes of
the table (more than two dimensions are possible!), while all other parameters
are passed unchanged to `InsuranceContract$new()`.


First, let us create a grid of premiums for different ages and maturities (for 
sum insured 100,000 Euro):
```{r SimpleExampleRiskPremiumGrid, eval=T, results="hide"}
grd = contractGridPremium(
  axes = list(age = seq(20, 80, 5), policyPeriod = seq(10, 40, 5)),
  tarif = Tarif.L71U, 
  contractClosing = as.Date("2020-08-18"), 
  sumInsured = 100000
)
grd
```
```{r SimpleExampleRiskPremiumGridOut, echo = F}
grd %>% kableTable(digits = 2)

```

One can also pass more than two dimensions to the axes:
```{r SimpleExampleRiskPremiumGrid3D, results = "hide"}
grd = contractGridPremium(
  axes = list(age = seq(20, 80, 10), policyPeriod = seq(10, 40, 10), sumInsured = c(10000, 50000, 100000)),
  tarif = Tarif.L71U, 
  contractClosing = as.Date("2020-08-18")
)
grd
```
```{r SimpleExampleRiskPremiumGrid3DOut, echo=F, results="asis"}
for (d in dimnames(grd)[[3]]) {
  cat("\n", "* , , ", names(dimnames(grd))[[3]], "=",  d, "\n\n", sep = "")
  # cat(grd[,,d ] %>% as.data.frame() %>% rownames_to_column("age \\|  policyPeriod") %>% pander(digits = 7, round = 2, style = "rmarkdown"))
  cat(grd[,,d ] %>% kableTable(digits = 2), "\n")
}

```


One can use any of the parameters of the `InsuranceContract$new()` call in the
`axes` argument, even the `tarif` or `mortalityTable` parameters. 
This means that one can create tables comparing different tariffs, or showing
the effect of different life tables.

In the following example, we use the tarif `Tarif.L71U`, but instead of the
unisex table (mixed 65:35 from male:female tables), we use the male mortality tables
of the Austrian census from 1870 to 2011 (with a contract period of 10 years fixed, and varying ages):

```{r SimpleExampleRiskPremiumGridLifeTables}
contractGridPremium(
  axes = list(mortalityTable = mort.AT.census["m", ], age = seq(20, 80, 10)),
  tarif = Tarif.L71U, 
  sumInsured = 100000,
  contractClosing = as.Date("2020-08-18")
) %>% pander(round=1, digits=15, keep.trailing.zeros = T)
```


# All possible parameters and their default values

All possible parameters of an insurance contract are stored in sub-lists of a a structure 
`InsuranceContract.Parameters`. If not provided by the call to `InsuranceContract$new()`, 
the values will be taken from either the `InsuranceTariff`'s default parameters, 
the `ProfitParticipation`'s default parameters or the global defaults in the 
`InsuranceContract.ParameterDefault`. The cascade or parameters is (from top to
bottom):

* explicit parameters passed to `InsuranceContract$addProfitScenario()` (applies 
  only for the added profit scenario)
* explicit parameters passed to `InsuranceContract$new()` or `InsuranceContract$clone()`
* parameters set with the `ProfitParticipation`
* parameters set with the `InsuranceTarif`
* Default values set in `InsuranceContract.ParameterDefaults`

In addition to the parameters listed below, the `InsuranceContract$new()`
constructor function takes the following parameters

\define{
\item{tarif}{The `InsuranceTarif` object describing the tarif}
\item{parent}{For contracts with multiple parts, children get passed a pointer to the parent}
\item{calculate}{How much of the contract to calculate (by default everything will be calculated)}
\item{profitid}{The profit ID for contracts with profit participation}
}

```{r}
str(InsuranceContract.ParameterDefaults)
```
```{r, results="asis"}

# pandoc.listRK(InsuranceContract.ParameterDefaults)
```

# Tarif Specification and implementation of a concrete contract

An insurance contract is modelled by the abstract product specification 
(`InsuranceTarif` class) and the concrete (individualized) `InsuranceContract`. 

* The `InsuranceTarif` object describes the product in abstract terms, holds
  default parameters and provides all calculation functions for cash flows, 
  present values, premiums and reserves (provided the contract's actual Parameters).
  It does not, however, hold contract-specific data.
* The `InsuranceContract` object holds the individual contract data (like age, contract 
  closing date, sum insured, etc.) that override the tariff's defaults. It also 
  holds a pointer to the insurance tariff and provides the general logic to
  calculate all parts of an insurance contract by calling the corresponding 
  functions of the tariff.

The insurance contract and the underlying insurance tariff have the same possible 
parameters in its constructors: The `InsuranceTarif` uses them to define defaults
for contracts that use the tariff, while the parameters passed to the contract
either provide the individually required data like age, sum insured or maturity, 
or they can override the defaults provided by the tariff. In theory, one could
even create a contract with an empty underlying tariff and provide all tariff-specific
parameters also in the contract's `new` call.

## Creating the tariff

The `InsuranceTarif` class provides a way to define an abstract insurance product.
The most important parameters to be passed in the  `InsuranceTarif$new()` call are:

**General settings for the Tariff**

* `name`, `tarif` and `desc` providing IDs and human-readable descriptions of the insurance product. They are just used as labels and array keys, but do not influence the calculations.
* `type` is the most important parameter, defining the type of life insurance product (endowment, pure endowment, annuity, whole life insurance, dread-disease insurance, etc.)

**Actuarial Bases for the Tariff**

* `mortalityTable` is a `MortalityTable` Object (package "MortalityTables"), providing the transition probabilities (typically death probabilities, but potentially also morbidity in dread-disease insurances)
* `i` Guaranteed interest rate
* `costs`, `unitcosts` are passed a data structure for all cost parameters (see below)
* `premiumFrequencyLoading` describes the surcharge for premium payments more often than yearly (as a named list)
* `premiumRefund` describes how much of the (gross) premium paid is returned upon death (often provided e.g. in deferred annuities or pure endowments with no fixed death benefit)
* `tax` is the insurance tax

**Benefit calculation**

* `surrenderValueCalculation` can be passed a hook function that calculates the surrender value given the current reserves at each time step



A typical call looks like the following for a pure endowment with gross premium
refund upon death and a linearly decreasing surrender penalty:



```{r TarifDefinition}
Tarif.PureEnd = InsuranceTarif$new(
  name = "Example Tariff - Pure Endowment",
  type = "pureendowment",
  tarif = "PE1-RP",
  desc = "A pure endowment with regular premiums (standard tariff)",

  mortalityTable = mort.AT.census.2011.unisex,
  i = 0.005,
  # Costs: 4% acquisition, where 2.5% are zillmered, 5\% of each premium as beta costs, 
  #        1%o acquisition costs of the sum insured over the whole contract period
  costs = initializeCosts(alpha = 0.04, Zillmer = 0.025, beta = 0.05, gamma.contract = 0.001, gamma.paidUp = 0.001),
  unitcosts = 10,

  # Yearly premiums get no surcharge, monthly premiums add +4%
  premiumFrequencyLoading = list("1" = 0, "12" = 0.04),
  premiumRefund = 1,  # Full gross premium refund upon death
  tax = 0.04,         # 4% insurance tas

  surrenderValueCalculation = function(surrenderReserve, params, values) {
    n = params$ContractData$policyPeriod
    # Surrender Penalty is 10% at the beginning and decreases linearly to 0%
    surrenderReserve * (0.9 + 0.1 * (0:n)/n)
  }
)
```

Many parameters do not need to be given explicitly, but instead use sensible 
defaults (like the `premiumPeriod`, which by default equals the whole contract 
period, i.e. regular premium payments over the whole contract duration).

To create a similar tariff with some changes, one can call the `createModification`
method of the `InsuranceTarif` clas, which takes as arguments all insurance 
parameters that should be changed for the new tarif. 

To create a single-premium version of the pure endowment shown above, one can simply
use a call like:

```{r TarifDefinitionSP}
Tarif.PureEnd.SP = Tarif.PureEnd$createModification(
  name = "Example Tariff - Pure Endowment (SP)",
  tarif = "PE1-SP",
  desc = "A pure endowment with single premiums",
  premiumPeriod = 1
)
```

### Sample tariffs for the most common types of life insurance

For the examples in the remainder of this vignette, we can create some more
example tariffs covering the most common types of life insurance. 


**General definitions for all tariffs**
```{r TarifDefinitions.All}
library(MortalityTables)
mortalityTables.load("Austria_Census")
mortalityTables.load("Austria_Annuities_AVOe2005R")
  # Costs: 4% acquisition, where 2.5% are zillmered, 5\% of each premium as beta costs, 
  #        1%o acquisition costs of the sum insured over the whole contract period
example.Costs = initializeCosts(
  alpha = 0.04, Zillmer = 0.025, 
  beta = 0.05, 
  gamma.contract = 0.001, gamma.paidUp = 0.001
)
example.Surrender = function(surrenderReserve, params, values) {
    n = params$ContractData$policyPeriod
    # Surrender Penalty is 10% at the beginning and decreases linearly to 0%
    surrenderReserve * (0.9 + 0.1 * (0:n)/n)
}
```
 
**Endowment**

```{r TarifDefinitions.All.End}
Tarif.Endowment = InsuranceTarif$new(
  name = "Example Tariff - Endowment",
  type = "endowment",
  tarif = "EN1",
  desc = "An endowment with regular premiums",

  mortalityTable = mort.AT.census.2011.unisex,
  i = 0.005,
  costs = example.Costs,
  unitcosts = 10,
  tax = 0.04,         # 4% insurance tax
  surrenderValueCalculation = example.Surrender
)
```

**Whole / Term Life Insurance**
```{r TarifDefinitions.All.Life}
Tarif.Life = InsuranceTarif$new(
  name = "Example Tariff - Whole/Term Life",
  type = "wholelife",
  tarif = "Life1",
  desc = "A whole or term life insurance with regular premiums",

  mortalityTable = mort.AT.census.2011.unisex,
  i = 0.005,
  costs = example.Costs,
  unitcosts = 10,
  tax = 0.04,         # 4% insurance tax
  surrenderValueCalculation = example.Surrender
)
```

**Immediate Annuity (single premium)**
```{r TarifDefinitions.All.ImmAnnuity}
Tarif.ImmAnnuity = InsuranceTarif$new(
  name = "Example Tariff - Immediate Annuity",
  type = "annuity",
  tarif = "Ann1",
  desc = "An annuity with single-premium",
  premiumPeriod = 1,

  mortalityTable = AVOe2005R.unisex,
  i = 0.005,
  costs = example.Costs,
  tax = 0.04         # 4% insurance tax
)
```

**Deferred Annuity**
```{r TarifDefinitions.All.DefAnnuity}
# Premium periods and deferral periods can also be given as a function of other
# contract parameters (like the age at contract inception, etc.)
Tarif.DefAnnuity = InsuranceTarif$new(
  name = "Example Tariff - Deferred Annuity",
  type = "annuity",
  tarif = "Life1",
  desc = "A deferred annuity (life-long payments start at age 65) with reg. premiums",

  contractPeriod = function(params, values) { 120 - params$ContractData$age},
  deferralPeriod = function(params, values) { 65 - params$ContractData$age},
  premiumPeriod = function(params, values) { 65 - params$ContractData$age},
    
  mortalityTable = AVOe2005R.unisex,
  i = 0.005,
  costs = example.Costs,
  tax = 0.04,         # 4% insurance tax
  surrenderValueCalculation = example.Surrender
)
```

**Dread-Disease Insurance**
```{r TarifDefinitions.All.DD}
# An example dread-disease tariff, morbidity is assumed linearly increasing with age
ddTable = mortalityTable.period(name = "Linear dread-disease table", 
                                ages = 0:100, deathProbs = 0:100/500)
Tarif.DreadDisease = InsuranceTarif$new(
  name = "Example Tariff - Dread-Disease",
  type = "dread-disease",
  tarif = "DD1",
  desc = "A dread disease insurance with a lump-sum payment upon diagnosis",

  sumInsured = 50000,
  mortalityTable = mort.AT.census.2011.unisex,
  invalidityTable = ddTable,
  i = 0.005,
  costs = example.Costs,
  unitcosts = 10,
  tax = 0.04,         # 4% insurance tax
  surrenderValueCalculation = example.Surrender
)
```

## Creating a contract for a given tariff

While the tariff describes the general product features, the contract object
holds the data of a concrete contract. All insurance parameters (see section 
[All possible parameters and their default values]) can be given to override
tarif defaults. 

However, the most important and often used parameters are:

**Information about insuree**

* `age` the age of the insured person at contract start
* `YOB` the year of birth of the insured person (`age`, `YOB` and `contractClosing` 
   are redundant, at most two need to be given). YOB is only relevant for 
   cohort mortality tables. For period life tables (which are independent of
   the birth year of the person), this parameter is not needed.
* `sex` is relevant for sex-specific life tables (common in the past)

**Contract details**

* `sumInsured` describes the benefit when the insured event happens. Typically
  the lump sum for whole life insurances or endowments, or the (yearly) payment
  for annuities
* `policyPeriod` defines the duration of the whole contract
* `premiumPeriod` defines how long premiums are paid (1 for single-premium 
  contracts, equal to `policyPeriod` (default) for regular premiums)
* `premiumFrequency` defines how often premiums are paid within a year (e.g. 
  1 for yearly premiums, 4 for quarterly, 12 for monthly)
* `contractClosing` describes the starting date of the contract
* `deathBenefitProportion` gives the factor of death benefit relative to the 
  survival benefit of endowments (1 means equal death and survival probabilities)
* `noMedicalExam`, `noMedicalExamRelative`, `sumRebate`, `extraRebate`, 
  `premiumRebate` describe various types of rebates or charges. They can either 
  be defined in general functional form in the tariff to apply to all contracts,
  or given individually for each contract. For the details, when each of these 
  rebates are applied, check the formula reference document.
  


For the pure endowments defined above, a typical contract would be created like
this:

```{r Contract}
contract.PureEnd = InsuranceContract$new(
    Tarif.PureEnd,
    age = 50, policyPeriod = 20, 
    premiumFrequency = 12,
    sumInsured = 100000,
    contractClosing = as.Date("2020-07-01")
  )
```

```{r Contract.premiums}
contract.PureEnd$Values$premiums
contract.PureEnd$Values$premiumComposition
```

Due to the full premium refund in case of death, there is only very little 
biometric risk involved. If the premium refund is not included in the contract,
then we have a negative biometric risk over the whole period (i.e. negative 
risk premium, because upon death the existing reserves is shared with the 
collective). The premium refund can be overridden directly in the contract call:

```{r ContractNoRefund}
contract.PureEnd.NoRefund = InsuranceContract$new(
    Tarif.PureEnd,
    age = 50, policyPeriod = 20, 
    premiumFrequency = 12,
    sumInsured = 100000,
    contractClosing = as.Date("2020-07-01"),
    premiumRefund = 0
  )

```
```{r Contract.premiumsCode, eval = F}
cbind(`With refund` = contract.PureEnd$Values$premiums, `Without refund` = contract.PureEnd.NoRefund$Values$premiums)
```{r Contract.premiumsOut, echo = F}
cbind(`With refund` = contract.PureEnd$Values$premiums, `Without refund` = contract.PureEnd.NoRefund$Values$premiums) %>% pander
```
```{r Contract.riskpremiumsCode, eval = F}
cbind(
  `Gross premium with refund` = contract.PureEnd$Values$premiumComposition[,"gross"],
  `Gross premium w/o refund` = contract.PureEnd.NoRefund$Values$premiumComposition[,"gross"],
  `Risk premium with refund` = contract.PureEnd$Values$premiumComposition[,"risk"],
  `Risk premium w/o refund` = contract.PureEnd.NoRefund$Values$premiumComposition[,"risk"]
)

```{r Contract.riskpremiumsOut, echo = F}
cbind(
  `Gross premium with refund` = contract.PureEnd$Values$premiumComposition[,"gross"],
  `Gross premium w/o refund` = contract.PureEnd.NoRefund$Values$premiumComposition[,"gross"],
  `Risk premium with refund` = contract.PureEnd$Values$premiumComposition[,"risk"],
  `Risk premium w/o refund` = contract.PureEnd.NoRefund$Values$premiumComposition[,"risk"]
) %>% as_tibble() %>% rowid_to_column("t") %>% mutate(t = t-1) %>% pander
```


To create a single-premium contract, one can either use the single-premium tarif
defined above, or simply pass `premiumPeriod=1` to the call:

```{r Contract.SP}
contract.PureEnd.SP1 = InsuranceContract$new(
    Tarif.PureEnd,
    age = 40, policyPeriod = 45, premiumPeriod = 1,
    sumInsured = 100000,
    contractClosing = as.Date("2020-07-01")
  )
contract.PureEnd.SP2 = InsuranceContract$new(
    Tarif.PureEnd.SP,
    age = 40, policyPeriod = 45, # premiumPeriod already set by tariff!
    sumInsured = 100000,
    contractClosing = as.Date("2020-07-01")
  )

all_equal(contract.PureEnd.SP1$Values$reserves, contract.PureEnd.SP2$Values$reserves)

```


## Premium Waivers

After a while, many customers do not want to pay premiums for the contract any 
more and convert the contract to a paid-up contract. The unit benefit cash flows
from that moment on stay the same, but the sum insured is adjusted, so that the 
existing reserve is able to cover all future benefits and costs. Furthermore,
paid-up contracts typically have differen costs / loadings. Additionally, the
surrender penalty is usually applied to the reserve before the conversion.

Waiving premiums and recalculating the sum insured is very easy, one just calls
the method `InsuranceContract$premiumWaiver(t = ..)` on the existing contract.

```{r Contract.PureEndPrf}
contract.PureEnd.NoRefund.Prf = contract.PureEnd.NoRefund$clone()$premiumWaiver(t = 7)
contract.PureEnd.NoRefund.Prf$Values$reserves
```

Notice that the contract changes are made directly to the contract ("reference semantics"). This is 
different from the typical behavior of R, where any change to e.g. a data.frame 
leaves the original data.frame intact and instead returns a modified copy.




# Calculation Approach


## Valuation

The calculation of all contract values is controlled by the function
`InsuranceContract$calculateContract()` (using methods of the `InsuranceTarif`
object) and follows the following logic:

1. First the **contingent (unit) cash flows** and the **transition probbilities**
are determined.
2. The **actuarial equivalence principle** states that at time of inception, the
(net and gross) premium must be determined in a way that the present value
of the future benefits and costs minus the present value of the future premiums
must be equal, i.e. in expectation the future premiums ove the whole lifetime
of the contract will exactly cover the benefits and costs. Similarly, at all
later time steps, the difference between these two present values needs to be
reserved (i.e. has already been paid by the customer by previous premiums).
2. This allows the premiums to be calculated by first calculating the **present
values** for all of the **benefit and costs cash flow** vectors.
3. The formulas
to calculate the gross, Zillmer and net **premiums** involve simple linear
combinations of these present values, so the **coefficients of these formulas**
are determined next.
4. With the coefficients of the premium formulas calculated, all **premiums
can be calculated** (first the gross premium, because due to potential gross
premium refunds in case of death, the formula for the net premium requires
the gross premium, which the formula for the gross premium involves no other
type of premuim).
5. With premiums determined, all unit cash flows and unit present values can
now be expressed in monetary terms / as **absolute cash flows** (i.e. the actual 
Euro-amount that flows rather than a percentage).
6. As described above, the difference between the present values of premiums
and present values of benefits and costs is defined as the required amount
of reserves, so the **reserves (net, gross, administration cost, balance sheet)**
and all values derived from them (i.e. surrender value, sum insured in case of
premium waiver, etc.) are calculated.
7. The **decomposition of the premium** into parts dedicated to specific purposes
(tax, rebates, net premium, gross premium, Zillmer premium, cost components,
risk premium, savings premium, etc.) can be done once the reserves are
ready (since e.g. the savings premium is defined as the difference of
discounted reserves at times $t$ and $t+1$).
8. If the contract has **(discretionary or obligatory) profit sharing**B mechanisms
included, the corresponding [ProfitParticipation] object can calculate that
profit sharing amounts, once all guaranteed values are calculated. This can
also be triggered manually (with custom profit sharing rates) by calling
the methods `InsuranceContract$profitScenario()` or `InsuranceContract$addProfitScenario()`.


## Cash Flows

An insurance contract is basically defined by the (unit) cash flows it produces:
\itemize{
  \item **Premium payments** (in advance or in arrears) at each timestep
  \item **Survival payments** at each timestep
  \item **Guaranteed payments** at each timestep
  \item **Death benefits** at each timestep
  \item **Disease benefits** at each timestep
}
Together with the transition probabilities (mortalityTable parameter)
the present values can be calculated, from which the premiums follow and
finally the reserves and a potential profit sharing.

For example, a _**term life insurance with regular premiums**_ would have the following
cash flows:

* premium cash flows: 1, 1, 1, 1, 1, ...
* survival cash flows: 0, 0, 0, 0, 0, ...
* guaranteed cash flows: 0, 0, 0, 0, 0, ...
* death benefit cash flows: 1, 1, 1, 1, 1, ...

A _**single-premium term life insurance**_ would look similar, except for the premiums:

* premium cash flows: 1, 0, 0, 0, 0, ...

A _**pure endowment**_ has no death benefits, but a survival benefit of 1 at the
maturity of the contract:

* premium cash flows: 1, 1, 1, 1, 1, ...
* survival cash flows: 0, 0, ..., 0, 1
* guaranteed cash flows: 0, 0, 0, 0, 0, ...
* death benefit cash flows: 0, 0, 0, 0, 0, ...

An _**endowment**_ has also death benefits during the contract duration:

* premium cash flows: 1, 1, 1, 1, 1, ...
* survival cash flows: 0, 0, ..., 0, 1
* guaranteed cash flows: 0, 0, 0, 0, 0, ...
* death benefit cash flows: 1, 1, 1, 1, 1, ...

A _**(deferred) annuity**B_ has premium cash flows only during the deferral peroid
and only survival cash flows during the annuity payment phase. Often, in case
of death during the deferral period, all premiums paid are refunded as a death
benefit.:

* premium cash flows: 1, 1, ...,  1, 0, 0, 0, ...
* survival cash flows: 0, 0, ..., 0, 1, 1, 1,...
* guaranteed cash flows: 0, 0, 0, 0, 0, ...
* death benefit cash flows: 1, 2, 3, 4, 5, ..., 0, 0, ...

A _**terme-fix insurance**_ has a guaranteed payment at maturity, even if the insured
has already died. The premiums, however, are only paid until death (which is
not reflected in the contingent cash flows, but rather in the transition
probabilities):

* premium cash flows: 1, 1, 1, 1, ...,  1
* survival cash flows: 0, 0, 0, 0, ..., 0
* guaranteed cash flows: 0, 0, 0, ..., 0, 1
* death benefit cash flows: 0, 0, 0, 0, ..., 0




# Cost structure

Costs of an insurance contracts can have various forms and bases.

The `InsuranceContract` class provides all common types of costs:


* Type of cost: Acquisition (Alpha-costs), Zillmer, Beta-costs, Administration (Gamma-costs during / after premiums and for paid-up contracts)
* Basis for costs: SumInsured, Premium Sum, Gross Premium, Net Premium, Reserve, constant costs
* Duration of costs: Once (up-front), during premium payments, after premium payments, during whole contract

The cost structure generated by `initializeCosts()` is a three-dimensional array
with the above-mentioned coordinates: 
```{r costStructureDimensions}
initializeCosts() %>% dimnames
```

The most common types of cost can be directly given in the call to `initializeCosts()`,
but for some uncommon combinations, one can directly fill any of the fields in the
three-dimensional array manually.
```{r costExample, eval=F}
initializeCosts(alpha = 0.04, Zillmer = 0.025, beta = 0.05, gamma.contract = 0.001)

# the above is the short form of:
costs.Bsp = initializeCosts()
costs.Bsp[["alpha", "SumPremiums", "once"]] = 0.04
costs.Bsp[["Zillmer", "SumPremiums", "once"]] = 0.025 # German Zillmer maximum
costs.Bsp[["beta", "GrossPremium", "PremiumPeriod"]] = 0.05
costs.Bsp[["gamma", "SumInsured", "PolicyPeriod"]] = 0.001
```

These costs parameters are immediately converted to the corresponding cash flows
when the contract is created. In the above example of a pure endowment (with 
premium waiver at time 7), the absolute cost cash flows are:

```{r costCashFlowsCode, eval=F}
contract.PureEnd.NoRefund$Values$absCashFlows
```
```{r costCashFlows, echo=F}
contract.PureEnd.NoRefund$Values$absCashFlows[1:11,] %>% select(alpha, Zillmer, beta, gamma, gamma_nopremiums, unitcosts) %>% pander()
```


In addition to these standardized costs, which are included in the expense-loaded
premium (sometimes also called the "(actuarial) gross premium"), there are certain
loadings and rebates that are applied after the expense-loaded premium $BP_x$:

$$P_x = \left\{ (BP_x + oUZu - SuRa) \cdot VS \cdot (1-VwGew) + unitC\right\} \cdot  \left(1-PrRa-VwGew_{StkK}-PartnerRa\right)\cdot \left(1+uz(k)\right) \cdot (1+tax)$$

with the following surcharges and rebates:

* $oUZu$ ... Surcharge for contracts without medical exam (parameter `noMedicalExam`)
* $SuRa$ ... Sum rebate (depending on the sum insured) (parameter `sumRebate`)
* $VwGew$ ... Advance profit participation (as premium rebate) (parameter `advanceProfitParticipation`)
* $unitC$ ... Unit costs per year (only during premium payments) (parameter `unitcosts`)
* $PrRa=PrRa(BP)$ ... Premium rebate (depending on premium amount) (parameter `premiumRebate`)
* $VwGew_{StkK}$ ... Advance profit participation (as premium rebate, on premium after unit costs) (parameter `advanceProfitParticipationInclUnitCost`)
* $PartnerRa$ ... Partner rebate on the premium (for multiple similar contracts) (parameter `partnerRebate`)
* $uz(k)$ ... Frequency charge for monthly/quarterly/half-yearly premium payments instead of yearly premiums (parameter `premiumFrequencyLoading`)
* $tax$ ... Insurance tax (0% in most countries, 4% or 11% in Austria) (parameter `tax`)






# Creating premium and contract grids

When developing a new product or comparing different products, it is often
required to create tables of premiums or reserves for a product/tarif where 
just some of the parameters (like age, sum insured or maturity) change. 

For this purpose, this package provides two functions to create two- or 
higher-dimensional grids of contracts with each dimension representing one 
of the parameters varying.

* `contractGrid()` creates a (two- or higher-dimensional) grid of `InsuranceContract` object
* `contractGridPremium()` creates a grid of the premiums

The grid is defined by the `axes` argument to the `contractGrid()` call. This is
a named list giving all parameters that should vary inside the grid. Any of the
parameters of the `InsuranceContract$new()` constructor can be used in the axes.

For example, one can compare multiple tariffs or multiple varying pararameters. 

Let us look at the pure endowment above, which we implemented as a single-premium
variant and a variant with regular premiums, both of which have a potential 
(partial or full) premium refund in case of death. How do the premiums of these
contracts compare and how do the premiums depend on the premium refund proportion?

```{r Grid.Endowment.compare}
contractGridPremium(
  axes = list(tarif = c(Tarif.PureEnd, Tarif.Endowment, Tarif.PureEnd.SP), premiumRefund = c(0, 0.5, 1)),
  age = 50, policyPeriod = 20,
  sumInsured = 10000,
  contractClosing = as.Date("2020-09-01")
)
```

The default implementation of `contractGridPremium` returns the written premium,
but one can also choose other types of premiums to display, or even other 
contract values (like reserves).

If one needs to investigate multiple values, it is better to first create a grid
of insurance contract objects and store it, so that the call to `contractGridPremium`
does not have to re-calculate the same contracts over and over again, extract just
one premium and discard the whole contract.

```{r Grid.Endowment.compareOther}
grd = contractGrid(
  axes = list(tarif = c(Tarif.PureEnd, Tarif.Endowment, Tarif.PureEnd.SP), premiumRefund = c(0, 0.5, 1)),
  age = 50, policyPeriod = 20,
  sumInsured = 10000,
  contractClosing = as.Date("2020-09-01")
)

# Compare net premiums without loadings:
contractGridPremium(grd, premium = "net")

# Compare premium sums over the whole contract period (all contracts have the same sumInsured)
contractGridPremium(grd, .fun = function(c) {c$Values$unitPremiumSum * c$Values$premiums["written"]})

# Compare risk premiums at time t=10 (the 11th row of the premium decomposition)
contractGridPremium(grd, .fun = function(c) {c$Values$premiumComposition[11, "risk"]})

# Compare present value of all benefits and refunds (without costs) at time t=0
contractGridPremium(grd, .fun = function(c) {c$Values$absPresentValues[1, "benefitsAndRefund"]})

```


Other usefil examples of grid comparisons include e.g. the effect of the interest 
rate and the mortality table on the premiums:

```{r Grid.Protection}
contractGridPremium(
  axes = list(mortalityTable = mort.AT.census["m", ], i = c(0, 0.005, 0.01), age = c(30, 45, 60), policyPeriod = c(10, 20)),
  tarif = Tarif.Life,
  contractClosing = as.Date("2020-09-01"),
  sumInsured = 10000
)
```

# Exporting contract data to Excel

The LifeInsuranceContracts package also provides a function to export a given 
contract to a spreadsheet in Excel format:

* `exportInsuranceContract.xlsx(contract, filename)`

This function takes the contract and exports all data.frames in the contract's 
`contract$Values` data list as separate tabs to a spreadsheet file. It also 
adds some nice formatting and additional markup. For contracts with multiple
contract blocks (e.g. dynamic increases / sum increases or riders), the main
contract and all its child blocks are exported as well.

The tab containing the premiums and the premium calculation coefficients even
include the formulas, so one can in theory play around with the parameters to 
see how the premium changes.

If the contract has profit participation features and some profit scenarios have 
been added, they are exported as well.

Notice, however, that the Excel export is in general a static file containing 
the current state of the contract and all its values (cash flows, present values,
premiums, reserves, profit participation, etc.) as well as the most important
parameters and an overview of the history of the contract.

```{r ExcelExport,eval=F}
contract.exportExample = contract.PureEnd.NoRefund$clone()$
  addDynamics(t = 3, SumInsuredDelta = 10000)$
  addDynamics(t = 5, SumInsuredDelta = 15000)$
  addDynamics(t = 10, SumInsuredDelta = 15000)$
  addDynamics(t = 14, SumInsuredDelta = 10000)
exportInsuranceContract.xlsx(contract.exportExample, filename = "Example_PureEndowment_Dynamics.xlsx")
```



# Creating example values required for submission to the Austrian Financial Market Authority

When introducing a new tariff, an Austrian insurance company has to submit
a detailled mathematical description (so-called "Versicherungsmathematische 
Grundlagen") of the tariff to the Financial Market Authority (FMA), which have
to follow the [regulation on actuarial bases for life insurance -- LV-VMGV](https://www.ris.bka.gv.at/GeltendeFassung.wxe?Abfrage=Bundesnormen&Gesetzesnummer=20009298). The sections and contents
of this document are strictly defined in the regulation, and in addition to the
formulas of the tariff, an example contract has to be calculated with the following
key parameters:

* age 35, duration 30 years (15 years for protection tariffs)
* sum insured 100 000 Euro / monthly annuity 1000 Euro for annuities
* yearly premiums during the whole contract period (defereal period of 30 years for annuities)
* intermediate values (reserves, etc.) have to be calculated at $t=10$.

Given a tariff and a derived contract (with the above key parameters), this
package provides two functions to calculate and print / export
the required values either to the console / screen or to a file:

* `showVmGlgExamples(contract, prf = 10, t = 10, t_prf = 12, file = "", ...)`
* `exportInsuranceContractExample(contract, prf = 10, outdir = ".", basename=NULL, extraname = NULL, ...)`

The function `showVmGlgExamples` calculates all required values for the actuarial
bases document in the required order (including values after a premium waiver 
at the given time). If a filename is given, the output is exported to that text file,
otherwise it is simply printed out in the R console:

```{r VmGlgExample}
VMGL.contract = InsuranceContract$new(
    Tarif.PureEnd,
    age = 35, policyPeriod = 30, 
    premiumFrequency = 1,
    sumInsured = 100000,
    contractClosing = as.Date("2020-07-01")
  )

showVmGlgExamples(VMGL.contract)
```


The `exportInsuranceContractExample` provides no new functionality, but combines 
the Excel export feature and the regulatory example together. For a given contract
it will create three files:

* Excel export of the contract
* Excel export of the contract with a premium waiver applied at the given time
* The regulatory example (with premium waiver at the same time as in the Excel export) in a text file

One can give a base name and an extra name to distinguish different calculations
in the file names.


# Handling contracts with increases (fixed increasing benefits / premiums, dynamic increases, sum increases)

While many insurance contracts have a fixed sum insured and constant premium,
many contracts include some kind of adjustment to account for inflation. There
are various ways to achieve such an adjustment:

* The initial contract already includes a planned increase in the benefits by a
  pre-determined factor $(1+s)$ each year, premiums are constant over the whole 
  duration. 
* The initial contract has fixed sum insured, but the premiums increase by a 
  factor $(1+s)$ each year due to salary increases.
* "Dynamic increases": The initial contract has fixed sum insured with fixed 
  regular premiums. However, every year (or triggered based on an inflation or 
  consumer price index) the sum insured is increased by a certain amount (either 
  fixed or by the same percentage as the index) and the premiums are increased 
  accordingly. Internally, this is represented by a second, shorter contract
  covering only the increase in sumInsured, from which the additional premium can 
  be calculated according to the tariff.

The LifeInsuranceContract package provides functionality for each of these increases. 
All three increases can in theory be combined in the same contract, although 
in practice this usually does not happen and at most one kind of increase is 
included in a contract

## Fixed yearly premium increase with constant sum insured

With this kind of increases, the initial contract valuation (i.e. the determination 
of the premium at contract inception) already takes into account that the premium
will not stay constant over the whole period,
but increases by a constant factor each year. The sum insured is calculated by 
the equivalence principle so that the expected present value of all future 
benefits and costs equals the expected present value of all future (i.e. 
increasing) premium payments.

This type of yearly premium increase by a fixed factor can be implemented by 
the parameter:

* `premiumIncrease` ... The factor, by which the premium increases yearly. Default is 1.0 (no increase in premium).

In the following example, we create a 20-year endowment contract with constant 
premiums over the whole period and another one with idential parameters except 
that the premium increases by 4\% each year:

```{r PremiumIncrease.Endowment, results = "hide"}
# For comparison: Contract with constant premiums
contract.Endow.Constant = InsuranceContract$new(
  tarif = Tarif.Endowment,
  sumInsured = 10000,
  age = 40, policyPeriod = 20,
  contractClosing = as.Date("2020-09-01")
)
# Contract with 4% yearly premium increase and same sum insured
contract.Endow.PremInc = InsuranceContract$new(
  tarif = Tarif.Endowment,
  sumInsured = 10000,
  premiumIncrease = 1.04,
  age = 40, policyPeriod = 20,
  contractClosing = as.Date("2020-09-01")
)
premium.comparison = data.frame(
  `Sum Insured` = contract.Endow.Constant$Values$basicData[,"SumInsured"],
  `Constant Premium` = contract.Endow.Constant$Values$basicData[,"Premiums"],
  `4% Yearly Increase` = contract.Endow.PremInc$Values$basicData[,"Premiums"],
  check.names = F
  )
```
```{r PremiumIncrease.EndowmentOut, results = "asis"}
premium.comparison %>% pander
```


## Fixed yearly benefit increase with constant premium

With this kind of increases, the premium will stay constant over the whole 
contract maturity, but the death and/or survival benefit (or the annuity payment)
will increase by a fixed factor each year. This is typically to safeguard the
benefit against inflation, so that the value of the annuity payment or death benefit
does not diminish due to inflation. The initial contract valuation (i.e. the determination 
of the constant premium at contract inception) already takes into account that 
the benefits will not stay constant over the whole period,
but increases by a constant factor each year. 

This type of yearly benefit increase by a fixed factor can be implemented by 
the parameters:

* `annuityIncrease` ... The factor, by which potential annuity payments increase yearly. Default is 1.0 (no increase in annuity benefits)
* `deathBenefit` ... The vector of death benefits (relative to the sum insured, which for endowments describes the survival benefit)

In the following example, we create a 20-year endowment contract with constant 
premiums over the whole period and another one with idential parameters except 
that the premium increases by 4\% each year:

```{r FixedSumIncrease.WholeLife, results = "hide"}
# For comparison: Contract with constant premiums
contract.TermLife.Constant = InsuranceContract$new(
  tarif = Tarif.Life,
  sumInsured = 10000,
  age = 40, policyPeriod = 20,
  contractClosing = as.Date("2020-09-01")
)
# Contract with 4% yearly increase in sum insured (final survival benefit is 10.000)
contract.TermLife.SumInc = InsuranceContract$new(
  tarif = Tarif.Life,
  sumInsured = 10000,
  deathBenefit = (1.04)^(0:20),
  age = 40, policyPeriod = 20,
  contractClosing = as.Date("2020-09-01")
)
premium.comparison = data.frame(
  `Const S.I.` = contract.TermLife.Constant$Values$absCashFlows[,"death"],
  `Const. Premium` = contract.TermLife.Constant$Values$absCashFlows[,"premiums_advance"],
  `4% sum increase` = contract.TermLife.SumInc$Values$absCashFlows[,"death"],
  `Premium w. sum increase` = contract.TermLife.SumInc$Values$absCashFlows[,"premiums_advance"],
  check.names = F
  )
```
```{r FixedSumIncrease.WholeLifeOut, results = "asis"}
premium.comparison %>% pander
```

For annuities, the benefit increase is not handled through `deathBenefits`, but
rather through the parameter

* `annuityIncrease` ... yearly increase factor of the annuity payments

In the following example, we create a 20-year endowment contract with constant 
premiums over the whole period and another one with idential parameters except 
that the premium increases by 4\% each year:

```{r FixedSumIncrease.Annuity, results = "hide"}
# For comparison: Contract with constant annuity
contract.Annuity.Constant = InsuranceContract$new(
  tarif = Tarif.DefAnnuity,
  sumInsured = 1200,
  age = 50, 
  policyPeriod = 20,
  deferralPeriod = 10,
  premiumPeriod = 10,
  contractClosing = as.Date("2020-09-01")
)
# Contract with 4% yearly increase in annuity benefits
contract.Annuity.Increasing = InsuranceContract$new(
  tarif = Tarif.DefAnnuity,
  sumInsured = 1200,
  annuityIncrease = 1.04,
  age = 50, 
  policyPeriod = 20,
  deferralPeriod = 10,
  premiumPeriod = 10,
  contractClosing = as.Date("2020-09-01")
)
# Contract with 4% yearly increase in premiums and in annuity payments
contract.Annuity.IncreasingBoth = InsuranceContract$new(
  tarif = Tarif.DefAnnuity,
  sumInsured = 1200,
  annuityIncrease = 1.04,
  premiumIncrease = 1.04,
  age = 50, 
  policyPeriod = 20,
  deferralPeriod = 10,
  premiumPeriod = 10,
  contractClosing = as.Date("2020-09-01")
)
premium.comparison = data.frame(
  `Const. Annuity` = contract.Annuity.Constant$Values$absCashFlows[,"survival_advance"],
  `Const. Premium` = contract.Annuity.Constant$Values$absCashFlows[,"premiums_advance"],
  `4% Annuity Increase` = contract.Annuity.Increasing$Values$absCashFlows[,"survival_advance"],
  `Premium w. Ann.Increase` = contract.Annuity.Increasing$Values$absCashFlows[,"premiums_advance"],
  `Inc.Premium w. Ann.Increase` = contract.Annuity.IncreasingBoth$Values$absCashFlows[,"premiums_advance"],
  check.names = F
  )
```
```{r FixedSumIncrease.AnnuityOut, results = "asis"}
premium.comparison %>% pander
```



## Dynamic Increases

With dynamic increases, the contract initially is written with a fixed sum insured
and constant premiums over the whole contract period. The future increases are
not considered at all.

After the initial contract inception, either yearly or when a consumer price 
index changes by a value larger than a given threshold, the sum insured is 
increased (either by a fixed amount or by an amount determined by the index change)
and the premium is adjusted accordingly. Internally, the original contract is
left untouched and the increase is modelled by a separate contract with the 
same key parameters, only with shorter duration and a sum insured that represents
only the increase. The premium for this increase is calculated like a separate
contract with only the difference in the over-all sum insured as its sum insured.

Each dynamic increase then adds another separate tiny InsuranceContract object 
and the over-all values are the sums of all those contract blocks (sometimes 
also called "contract slices").

The `InsuranceContract` class provides a method to add a dynamic increase:

* `InsuranceContract$addDynamics(t, NewSumInsured, SumInsuredDelta, id, ...)`

Only one of `NewSumInsured` (new total sum insured) and `SumInsuredDelta` (only 
the difference between old and new sum insured) is needed. This method adds a
new contract block to the given InsuranceContract, starting at time $t$ with 
`SumInsuredDelta` as its sum insured and its premium calculated from the 
shorter contract period and the sum insured delta. These blocks for dynamic increases 
are stored in the contract's `$blocks` list of children. The values stored in the
contract are then simply the sum of all its children.

Here is an example of a 10-year endowment, which has dynamic increases at times $t=5$, $t=7$ and $t=8$:


```{r DynamicIncrease.Endowment}
# For comparison: Contract with constant annuity
contract.Endowment.Dynamics = InsuranceContract$new(
  tarif = Tarif.Endowment,
  sumInsured = 10000,
  age = 40, 
  policyPeriod = 10,
  contractClosing = as.Date("2020-09-01"),
  id = "Initial contract"
)$
  addDynamics(t = 5, NewSumInsured = 11000, id = "Dynamic at 5")$
  addDynamics(t = 7, NewSumInsured = 12000, id = "Dynamic at 7")$
  addDynamics(t = 8, NewSumInsured = 13500, id = "Dynamic at 8")

# Over-all contract sum insured and premiums for all blocks combined
contract.Endowment.Dynamics$Values$basicData[,c("SumInsured", "Premiums")] %>% pander
```
```{r DynamicIncrease.EndowmentOut, results = "asis", echo = F}
blk = c(list(`Over-all contract` = contract.Endowment.Dynamics), contract.Endowment.Dynamics$blocks)

padArray = function(arr = NULL, pad = 0, len = 0) {
  padEnd = max(0, len - pad - NROW(arr)) # if len is too short, return an array containing at least the arr
  nrcols = ifelse(is.null(arr), 0, NCOL(arr))
  rbind(
    array(0, dim = c(pad, nrcols)) %>% `colnames<-`(colnames(arr)),
    arr,
    array(0, dim = c(padEnd, nrcols)) %>% `colnames<-`(colnames(arr))
  ) %>% `colnames<-`(colnames(arr))
}

lapply(blk, function(b) {
  basic = padArray(b$Values$basicData, pad = b$Parameters$ContractData$blockStart)
  basic[,"SumInsured"]
}) %>% 
  bind_cols() %>% 
  rowid_to_column("t") %>% 
  mutate(t = t-1) %>% 
  pander(caption = "Sum Insured for the over-all contract and each of the blocks")

lapply(blk, function(b) {
  basic = padArray(b$Values$basicData, pad = b$Parameters$ContractData$blockStart)
  basic[,"Premiums"]
}) %>% 
  bind_cols() %>% 
  rowid_to_column("t") %>% 
  mutate(t = t-1) %>% 
  pander(caption = "Premium time series for the over-all contract and each of the blocks")

```

# Advance profit participation (premium rebate)

TODO

# Profit participation schemes

TODO

# Modifying the default calculation approach

TODO

